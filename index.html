<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Table Reference System</title>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.23.4/full/pyodide.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Arial, sans-serif;
            background: #f0f2f5;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 30px;
        }
        
        h1 {
            color: #333;
            margin-bottom: 20px;
        }
        
        .narrative {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
            line-height: 1.8;
        }
        
        .narrative h2 {
            color: #555;
            margin-bottom: 15px;
            font-size: 1.3em;
        }
        
        .narrative h4 {
            color: #666;
            margin: 15px 0 10px 0;
            font-size: 1em;
        }
        
        .link {
            color: #0066cc;
            text-decoration: none;
            font-weight: bold;
            cursor: pointer;
            border-bottom: 1px dotted #0066cc;
        }
        
        .link:hover {
            background: #e6f2ff;
            padding: 2px 4px;
            border-radius: 3px;
        }
        
        .tooltip {
            position: fixed;
            background: #333;
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 0.9em;
            max-width: 500px;
            z-index: 1000;
            display: none;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
        
        .tooltip-item {
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid #555;
        }
        
        .tooltip-item:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }
        
        .tooltip-row-label {
            color: #7cb3ff;
            font-weight: bold;
            margin-bottom: 4px;
        }
        
        .tooltip-col {
            margin-left: 10px;
            margin-top: 3px;
        }
        
        .tooltip-col-label {
            color: #aaa;
            font-size: 0.85em;
        }
        
        .table-section {
            margin-bottom: 30px;
        }
        
        .table-section h3 {
            color: #555;
            margin-bottom: 10px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        
        th, td {
            padding: 10px;
            text-align: left;
            border: 1px solid #ddd;
        }
        
        th {
            background: #0066cc;
            color: white;
        }
        
        tr:hover {
            background: #f5f5f5;
        }
        
        tr.highlight {
            background: #fff3cd !important;
        }
        
        td.highlight-cell {
            background: #ffe066 !important;
            font-weight: bold;
        }
        
        .detail-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            max-width: 700px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 2000;
            display: none;
        }
        
        .detail-panel.active {
            display: block;
        }
        
        .detail-panel h3 {
            color: #333;
            margin-bottom: 15px;
        }
        
        .detail-group {
            margin-bottom: 20px;
            padding: 15px;
            background: #f0f4f8;
            border-radius: 8px;
            border-left: 4px solid #0066cc;
        }
        
        .detail-group-title {
            font-weight: bold;
            color: #0066cc;
            margin-bottom: 10px;
            font-size: 1.1em;
        }
        
        .detail-row {
            margin-bottom: 10px;
            padding: 8px;
            background: white;
            border-radius: 5px;
        }
        
        .detail-row.highlighted {
            background: #fff3cd;
            border: 1px solid #ffc107;
        }
        
        .detail-label {
            font-weight: bold;
            color: #0066cc;
        }
        
        .close-btn {
            background: #0066cc;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            float: right;
        }
        
        .close-btn:hover {
            background: #0052a3;
        }
        
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1500;
            display: none;
        }
        
        .overlay.active {
            display: block;
        }
        
        .legend {
            background: #e8f4f8;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            font-size: 0.9em;
        }
        
        .legend h4 {
            margin-bottom: 10px;
            color: #333;
        }
        
        .legend code {
            background: #d4e8f0;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
        }
        
        /* Markdown content styles */
        .narrative h1, .narrative h2, .narrative h3, .narrative h4 {
            margin-top: 15px;
            margin-bottom: 10px;
        }
        
        .narrative ul, .narrative ol {
            margin: 10px 0;
            padding-left: 25px;
        }
        
        .narrative li {
            margin: 5px 0;
        }
        
        .narrative blockquote {
            border-left: 4px solid #0066cc;
            margin: 15px 0;
            padding: 10px 15px;
            background: #e6f2ff;
            border-radius: 0 5px 5px 0;
        }
        
        .narrative pre {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
        }
        
        .narrative code {
            background: #e8e8e8;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        .narrative pre code {
            background: none;
            padding: 0;
        }
        
        .narrative hr {
            border: none;
            border-top: 2px solid #ddd;
            margin: 20px 0;
        }
        
        .narrative img {
            max-width: 100%;
            border-radius: 5px;
            margin: 10px 0;
        }
        
        .narrative a:not(.link) {
            color: #0066cc;
            text-decoration: underline;
        }

        /* Hide table sections by default; user chooses which to display */
        .table-section.hidden-table {
            display: none;
        }

        /* Table selector dropdown */
        .table-controls {
            margin: 15px 0 20px;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .dropdown {
            position: relative;
            display: inline-block;
        }

        .dropdown button {
            background: #0066cc;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            min-width: 140px;
            transition: background .15s ease, transform .08s ease;
        }

        .dropdown button:hover { background: #0052a3; transform: translateY(-1px); }

        /* Use visibility/opacity for smooth transitions */
        .dropdown-content {
            visibility: hidden;
            opacity: 0;
            transform: translateY(-6px);
            transition: opacity .16s ease, transform .16s ease, visibility .16s;
            position: absolute;
            background: white;
            border: 1px solid #e6eef6;
            min-width: 260px;
            max-height: 320px;
            overflow-y: auto;
            padding: 10px;
            box-shadow: 0 10px 30px rgba(6,60,100,0.08);
            z-index: 3000;
            border-radius: 8px;
        }

        .dropdown.open .dropdown-content { visibility: visible; opacity: 1; transform: translateY(0); }

        .table-option { display: flex; align-items: center; gap: 12px; padding: 8px 6px; }
        .table-option { position: relative; }

        /* Hide the native checkbox and create a custom visual using label pseudo elements */
        .table-option input[type="checkbox"] { position: absolute; left: 0; top: 0; width: 20px; height: 20px; opacity: 0; pointer-events: auto; }
        .table-option label { cursor: pointer; padding-left: 32px; display: block; line-height: 1.1; color: #233; }

        .table-option label::before {
            content: '';
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
            height: 20px;
            border-radius: 6px;
            border: 2px solid #cfd8dc;
            background: #fff;
            box-shadow: 0 1px 3px rgba(14,20,30,0.04);
            transition: all .14s ease;
        }

        .table-option input[type="checkbox"]:checked + label::before {
            background: linear-gradient(135deg,#00c6ff,#0066cc);
            border-color: #0066cc;
            box-shadow: 0 6px 16px rgba(0,102,204,0.16);
        }

        .table-option label::after {
            content: '';
            position: absolute;
            left: 6px;
            top: 50%;
            transform: translateY(-50%) rotate(45deg) scale(0);
            width: 6px;
            height: 11px;
            border: solid #fff;
            border-width: 0 2px 2px 0;
            transition: transform .12s ease;
        }

        .table-option input[type="checkbox"]:checked + label::after {
            transform: translateY(-50%) rotate(45deg) scale(1);
        }

        .table-option label:hover::before { transform: translateY(-52%); border-color: #9fb6cc; }

        /* Responsive behavior */
        @media (max-width: 600px) {
            .table-controls { flex-direction: column; align-items: stretch; gap: 8px; }
            .dropdown { width: 100%; }
            .dropdown button { width: 100%; text-align: left; }
            .dropdown-content { position: fixed; left: 10px; right: 10px; top: 72px; min-width: auto; max-height: 60vh; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸ“Š Interactive Table Reference System</h1>

        <div class="table-controls">
            <div style="font-weight:bold; color:#333;">Show tables:</div>
            <div class="dropdown" id="tableDropdownWrapper">
                <button id="tableDropdownBtn">Select tables â–¾</button>
                <div class="dropdown-content" id="tableDropdown">
                    <div id="tableList"></div>
                </div>
            </div>
            <div style="color:#666; font-size:0.95em;">Select one or more tables to display</div>
        </div>
        
        <div class="narrative">
            <h2>Project Summary</h2>
            
            <h4>Basic References (Single Row, Single/No Column)</h4>
            <p class="auto-link-refs">
                The validation process reviewed entry R(14,2) successfully. Item I(1,2.a) showed improvement. Test I(1,3.0.a.P) needs review. Check the status: R(1,2,3).
            </p>
            
            <h4>Single Row, Multiple Columns</h4>
            <p class="auto-link-refs">
                View ID and Status for row 1: I(1,1.0,1+3). See Text, Status, Remark: R(1,1,2+3+4). Experiment 001 Result & Remark: I(2,001,3+4).
            </p>
            
            <h4>Multiple Rows, Single Column</h4>
            <p class="auto-link-refs">
                Compare results R(14,5+7,2+3) for analysis. See rows R(1,1+2,3) status comparison. All experiment IDs: R(2,1+2+3,1).
            </p>
            
            <h4>Range Syntax (Using -)</h4>
            <p class="auto-link-refs">
                Rows 1-3, Status column: R(14,1-3,3). IDs 001-003, Result column: I(2,001-003,3). Row 1, Columns 2-4: R(1,1,2-4). Mixed: R(2,1-3,3+4) and I(2,001-002,2-4).
            </p>
            
            <h4>Continuous Display (Using *)</h4>
            <p class="auto-link-refs">
                Combined text from IDs 1.0 and 2.a: I(1,1.0*2.a*3.0.a.P,2). All statuses in one line: R(1,1*2*3,3). Mixed (1.0*2.a on one line, 3.0.a.P on new line): I(1,1.0*2.a+3.0.a.P,2).
            </p>
            
            <h4>Multiple Rows, Multiple Columns</h4>
            <p class="auto-link-refs">
                Full comparison 001 & 002 (Result + Remark): I(2,001+002,3+4). Table 1 rows 1-3 (Status + Remark): R(1,1+2+3,3+4). All experiments (ID + Result): I(2,001+002+003,1+3).
            </p>
            
            <h4>Full Row References (No Column Specified)</h4>
            <p class="auto-link-refs">
                Full details: I(2,001+002+003). Row comparison: R(2,1+2+3).<br>
                This is after line break I(2,001+002,3)<br>
                This is R(1,1*2*3,3) check.
            </p>

            <h4>All Rows / All Columns Examples</h4>
            <p class="auto-link-refs">
                Example: View all rows in Table 2's first column: R(2,all,1). See full table 1: I(1,all,all).
            </p>
        </div>
        
        <div class="table-section">
            <h3>Table 1: Validation Results</h3>
            <table id="T1">
                <thead>
                    <tr>
                        <th>ID</th>
                        <th>Text</th>
                        <th>Status</th>
                        <th>Remark</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>1.0</td>
                        <td>Primary validation completed</td>
                        <td>Passed</td>
                        <td>All criteria met</td>
                    </tr>
                    <tr>
                        <td>2.a</td>
                        <td>Performance metrics improved</td>
                        <td>Passed</td>
                        <td>20% increase over baseline</td>
                    </tr>
                    <tr>
                        <td>3.0.a.P</td>
                        <td>Testing phase insights</td>
                        <td>Review</td>
                        <td>Additional analysis needed</td>
                    </tr>
                </tbody>
            </table>
        </div>
        
        <div class="table-section">
            <h3>Table 2: Experiment Data</h3>
            <table id="T2">
                <thead>
                    <tr>
                        <th>ID</th>
                        <th>Text</th>
                        <th>Result</th>
                        <th>Remark</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>001</td>
                        <td>Promising experimental results</td>
                        <td>Positive</td>
                        <td>Exceeded performance by 15%</td>
                    </tr>
                    <tr>
                        <td>002</td>
                        <td>Sample requiring verification</td>
                        <td>Pending</td>
                        <td>Secondary validation scheduled</td>
                    </tr>
                    <tr>
                        <td>003</td>
                        <td>Control group baseline</td>
                        <td>Stable</td>
                        <td>Consistent performance</td>
                    </tr>
                </tbody>
            </table>
        </div>
        
        <div class="legend">
            <h4>Reference Syntax Guide</h4>
            <p><code>I(table, id)</code> - Reference by ID value</p>
            <p><code>R(table, row)</code> - Reference by row number</p>
            <p><code>I(table, id, col)</code> - Single row, single column</p>
            <p><code>I(table, id, col1+col2)</code> - Single row, multiple columns (using +)</p>
            <p><code>I(table, id1+id2, col)</code> - Multiple rows, single column (using +) - separate lines</p>
            <p><code>I(table, id1+id2, col1+col2)</code> - Multiple rows, multiple columns</p>
            <p><code>R(table, row1-row3, col)</code> - Row range (using -), e.g., 1-3 = rows 1,2,3</p>
            <p><code>I(table, id1-id3, col1-col3)</code> - ID range and column range</p>
            <p><code>R(table, 1-3+5, 2-4)</code> - Mixed: range + individual values</p>
            <p><code>I(table, id1*id2, col)</code> - Continuous display (using *) - content on same line</p>
            <p><code>I(table, id1*id2+id3, col)</code> - Mixed: id1*id2 on one line, id3 on new line</p>
            <p><code>I(table, all, all)</code> - All rows and all columns of the table</p>
            <p><code>R(table, all, col)</code> - All rows of the table for the specified column</p>
        </div>
        
        <div class="narrative" style="margin-top: 20px;">
            <h2>Auto-Linked Content Demo</h2>
            <div id="autoLinkedDemo" class="auto-link-refs">
                This text has auto-detected references: The experiment R(2,1-3,3) shows positive results. Compare I(1,1.0) with I(1,2.a) for validation insights. Full data available at I(2,001-003,1+3).<br>
                Try these new examples: R(2,all,1) and I(1,all,all).
            </div>
        </div>
        
        <div class="narrative" style="margin-top: 20px;">
            <h2>External Content Container</h2>
            <div id="externalContent" class="auto-link-refs">
                <!-- Example content demonstrating references to external table data -->
                <p>
                    External table examples (from <code>datanoteU14.js</code>):
                </p>
                <ul>
                    <li>Single cell (Name of Licence 1): <a class="link" data-ref="I(14,1,2)" href="#">I(14,1,2)</a></li>
                    <li>Multiple columns (Name + Sex of Licence 1): <a class="link" data-ref="I(14,1,2+4)" href="#">I(14,1,2+4)</a></li>
                    <li>Row range (Names of rows 1-3): <a class="link" data-ref="R(14,1-3,2)" href="#">R(14,1-3,2)</a></li>
                    <li>All rows for Name column: <a class="link" data-ref="R(14,all,2)" href="#">R(14,all,2)</a></li>
                    <li>Full table display: <a class="link" data-ref="I(14,all,all)" href="#">I(14,all,all)</a></li>
                </ul>
            </div>
        </div>
        
        <div class="narrative" style="margin-top: 20px;">
            <h2>Markdown Content Container</h2>
            <div id="markdownContent"></div>
        </div>
    </div>
    
    <div class="tooltip" id="tooltip"></div>
    <div class="overlay" id="overlay"></div>
    <div class="detail-panel" id="detailPanel">
        <button class="close-btn" onclick="closeDetail()">Close</button>
        <h3 id="detailTitle">Details</h3>
        <div id="detailContent"></div>
    </div>
    
    <script>
        let pyodide;
        
        async function initPyodide() {
            pyodide = await loadPyodide();
            
            await pyodide.runPythonAsync(`
def get_row_by_id(table_id, row_id):
    """Find row by ID value"""
    return {'table': table_id, 'id': row_id, 'type': 'id'}

def get_row_by_number(table_id, row_num):
    """Find row by row number (1-indexed)"""
    return {'table': table_id, 'row': row_num, 'type': 'row'}
            `);
            
            setupEventListeners();
        }
        
        function setupEventListeners() {
            const links = document.querySelectorAll('.link');
            
            links.forEach(link => {
                link.addEventListener('mouseenter', (e) => showTooltip(e, link));
                link.addEventListener('mouseleave', hideTooltip);
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    showDetail(link);
                });
            });
            
            document.getElementById('overlay').addEventListener('click', closeDetail);
        }
        
        function expandRange(str, isNumeric = true) {
            // Expand range syntax: "1-3" becomes ["1","2","3"], "001-003" becomes ["001","002","003"]
            // Also handles + syntax: "1+2+3" or mixed "1-3+5"
            // Also handles * syntax: "1.0*2.a" for continuous display (returns object with flag)
            // Mixed: "1.0*2.a+3.0.a.P" means 1.0 and 2.a on same line, 3.0.a.P on new line
            
            // Split by + first to get separate line groups
            const plusParts = str.split('+').map(p => p.trim());
            const result = [];
            let continuousGroups = []; // Track which items should be displayed continuously
            
            for (const plusPart of plusParts) {
                if (plusPart.includes('*')) {
                    // This is a continuous group (items joined by *)
                    const continuousItems = plusPart.split('*').map(s => s.trim());
                    const groupStart = result.length;
                    
                    continuousItems.forEach(item => {
                        if (item.includes('-')) {
                            // Handle range within continuous group
                            const expanded = expandRangeSimple(item, isNumeric);
                            result.push(...expanded);
                        } else {
                            result.push(item);
                        }
                    });
                    
                    // Mark this group as continuous (start to end indices)
                    continuousGroups.push({ start: groupStart, end: result.length - 1 });
                } else if (plusPart.includes('-')) {
                    // Range without continuous - each item is separate
                    const expanded = expandRangeSimple(plusPart, isNumeric);
                    result.push(...expanded);
                } else {
                    // Single item
                    result.push(plusPart);
                }
            }
            
            const hasContinuous = continuousGroups.length > 0;
            
            return { values: result, continuousGroups, hasContinuous };
        }
        
        function expandRangeSimple(part, isNumeric) {
            // Simple range expansion helper
            const result = [];
            const [startStr, endStr] = part.split('-').map(s => s.trim());
            
            if (isNumeric) {
                // Numeric range (for row numbers or column numbers)
                const start = parseInt(startStr);
                const end = parseInt(endStr);
                // Preserve leading zeros if present
                const padLength = startStr.length;
                for (let i = start; i <= end; i++) {
                    result.push(String(i).padStart(padLength, '0'));
                }
            } else {
                // ID range - try to detect numeric suffix pattern
                const startMatch = startStr.match(/^(.*?)(\d+)$/);
                const endMatch = endStr.match(/^(.*?)(\d+)$/);
                
                if (startMatch && endMatch && startMatch[1] === endMatch[1]) {
                    // Same prefix, numeric suffix
                    const prefix = startMatch[1];
                    const startNum = parseInt(startMatch[2]);
                    const endNum = parseInt(endMatch[2]);
                    const padLength = startMatch[2].length;
                    
                    for (let i = startNum; i <= endNum; i++) {
                        result.push(prefix + String(i).padStart(padLength, '0'));
                    }
                } else {
                    // Can't expand, just add as-is
                    result.push(part);
                }
            }
            return result;
        }
        
        function parseReference(ref) {
            // Parse format: I(tableNum, id) or R(tableNum, rowNum) or with column(s)
            // Supports multiple values with + separator and - range for both rows and columns
            // Supports * for continuous display (no line breaks)
            // Adds support for "all" to represent all rows or all columns
            // Examples: I(1,1.0), R(1,2), I(1,1.0,2), R(1,2,3), 
            //           I(2,001+002,3), R(1,1+2+3), I(1,1.0,1+3), I(2,001+002,3+4)
            //           R(1,1-3,3) - rows 1 to 3, column 3
            //           I(2,001-003,3+4) - IDs 001 to 003, columns 3 and 4
            //           I(1,1.0*2.a) - IDs 1.0 and 2.a displayed continuously
            //           I(1,all,all) - all rows and all columns
            const match = ref.match(/([IR])\((\d+),([^,\)]+)(?:,([^,\)]+))?\)/);
            if (!match) return null;
            
            const refType = match[1]; // 'I' for ID, 'R' for Row
            const tableNum = match[2];
            const valueStr = match[3].trim();
            const colStr = match[4] ? match[4].trim() : null; // Optional column(s)
            
            // Handle special token 'all' for rows
            let rowValues = [];
            let continuousGroups = [];
            let hasContinuous = false;
            let isAllRows = false;

            if (valueStr.toLowerCase() === 'all') {
                isAllRows = true;
                rowValues = ['all'];
            } else {
                const rowExpanded = expandRange(valueStr, refType === 'R');
                rowValues = rowExpanded.values;
                continuousGroups = rowExpanded.continuousGroups;
                hasContinuous = rowExpanded.hasContinuous;
            }
            
            // Expand column numbers (always numeric), and support 'all' for columns
            let colNums = null;
            let allCols = false;
            if (colStr) {
                if (colStr.toLowerCase() === 'all') {
                    allCols = true;
                } else {
                    const colExpanded = expandRange(colStr, true);
                    colNums = colExpanded.values.map(c => parseInt(c));
                }
            }
            
            // Get table by number (1-indexed). Prefer an explicit table id like 'T14' if present.
            let tableId = null;
            const explicitTable = document.getElementById('T' + tableNum);
            if (explicitTable) {
                tableId = explicitTable.id;
            } else {
                const tables = document.querySelectorAll('table');
                tableId = tables[tableNum - 1]?.id;
            }
            
            return { 
                tableId, 
                refType, 
                rowValues, 
                colNums,
                isAllRows,
                allCols,
                isMultiRow: rowValues.length > 1 && !isAllRows,
                isMultiCol: (colNums && colNums.length > 1) || allCols,
                continuousGroups,
                hasContinuous
            };
        }
        
        function findRow(tableId, refType, value) {
            const table = document.getElementById(tableId);
            if (!table) return null;
            
            const tbody = table.querySelector('tbody');
            
            if (refType === 'R') {
                // Row number reference
                const rowNum = parseInt(value);
                return tbody.rows[rowNum - 1]; // Convert to 0-indexed
            } else if (refType === 'I') {
                // ID reference - search for it in first column
                const rows = tbody.querySelectorAll('tr');
                for (let row of rows) {
                    if (row.cells[0].textContent === value) {
                        return row;
                    }
                }
            }
            
            return null;
        }
        
        function findRows(link) {
            const ref = link.getAttribute('data-ref');
            const parsed = parseReference(ref);
            if (!parsed) return [];
            
            const rows = [];
            const table = document.getElementById(parsed.tableId);
            if (!table) return rows;
            const tbody = table.querySelector('tbody');
            if (!tbody) return rows;
            
            // If 'all' rows requested, return every row in the tbody
            if (parsed.isAllRows) {
                const allRows = Array.from(tbody.querySelectorAll('tr'));
                for (const tr of allRows) {
                    const id = tr.cells[0]?.textContent || '';
                    rows.push({ row: tr, value: id });
                }
                return rows;
            }

            for (const value of parsed.rowValues) {
                const row = findRow(parsed.tableId, parsed.refType, value);
                if (row) {
                    rows.push({ row, value });
                }
            }
            
            return rows;
        }
        
        function getHeaders(tableId) {
            const table = document.getElementById(tableId);
            if (!table) return [];
            return Array.from(table.querySelectorAll('th')).map(th => th.textContent);
        }
        
        function getCellContents(link) {
            const ref = link.getAttribute('data-ref');
            const parsed = parseReference(ref);
            const rowData = findRows(link);
            const headers = getHeaders(parsed.tableId);
            
            if (rowData.length === 0) return [];
            
            const contents = [];
            for (const { row, value } of rowData) {
                const rowContent = {
                    id: value,
                    columns: []
                };
                
                if (parsed.colNums !== null) {
                    // Specific column(s) requested
                    for (const colNum of parsed.colNums) {
                        const cellIndex = colNum - 1; // Convert to 0-indexed
                        rowContent.columns.push({
                            colNum: colNum,
                            header: headers[cellIndex] || `Column ${colNum}`,
                            content: row.cells[cellIndex]?.textContent || 'N/A'
                        });
                    }
                } else if (parsed.allCols) {
                    // All columns requested
                    const cells = row.querySelectorAll('td');
                    for (let i = 0; i < cells.length; i++) {
                        rowContent.columns.push({
                            colNum: i + 1,
                            header: headers[i] || `Column ${i + 1}`,
                            content: cells[i]?.textContent || 'N/A'
                        });
                    }
                } else {
                    // Default: return Text column (column 2)
                    rowContent.columns.push({
                        colNum: 2,
                        header: headers[1] || 'Text',
                        content: row.cells[1]?.textContent || 'N/A'
                    });
                }
                
                contents.push(rowContent);
            }
            
            return contents;
        }
        
        function showTooltip(e, link) {
            const contents = getCellContents(link);
            const parsed = parseReference(link.getAttribute('data-ref'));
            
            if (contents.length > 0) {
                const tooltip = document.getElementById('tooltip');
                
                // Check if we have continuous groups with mixed + syntax
                if (parsed && parsed.hasContinuous && parsed.continuousGroups.length > 0) {
                    // Build tooltip respecting continuous groups
                    let html = '';
                    let i = 0;
                    
                    while (i < contents.length) {
                        const continuousGroup = parsed.continuousGroups.find(g => i >= g.start && i <= g.end);
                        
                        if (continuousGroup && i === continuousGroup.start) {
                            // Continuous group - join content on same line
                            const groupContent = [];
                            for (let j = continuousGroup.start; j <= continuousGroup.end; j++) {
                                groupContent.push(contents[j].columns.map(col => col.content).join(' '));
                            }
                            html += `<div class="tooltip-item">${groupContent.join(' ')}</div>`;
                            i = continuousGroup.end + 1;
                        } else if (!continuousGroup) {
                            // Not in continuous group - separate line
                            html += `<div class="tooltip-item">${contents[i].columns.map(col => col.content).join(' ')}</div>`;
                            i++;
                        } else {
                            i++;
                        }
                    }
                    tooltip.innerHTML = html;
                }
                // Single row, single column - simple display
                else if (contents.length === 1 && contents[0].columns.length === 1) {
                    tooltip.innerHTML = contents[0].columns[0].content;
                } 
                // Single row, multiple columns
                else if (contents.length === 1) {
                    let html = `<div class="tooltip-item">`;
                    for (const col of contents[0].columns) {
                        html += `<div class="tooltip-col">
                            <span class="tooltip-col-label">${col.header}:</span> ${col.content}
                        </div>`;
                    }
                    html += '</div>';
                    tooltip.innerHTML = html;
                }
                // Multiple rows
                else {
                    let html = '';
                    for (const item of contents) {
                        html += `<div class="tooltip-item">
                            <div class="tooltip-row-label">${item.id}</div>`;
                        for (const col of item.columns) {
                            html += `<div class="tooltip-col">
                                <span class="tooltip-col-label">${col.header}:</span> ${col.content}
                            </div>`;
                        }
                        html += '</div>';
                    }
                    tooltip.innerHTML = html;
                }
                
                tooltip.style.display = 'block';
                tooltip.style.left = Math.min(e.clientX, window.innerWidth - 520) + 'px';
                tooltip.style.top = (e.clientY + 20) + 'px';
            }
        }
        
        function hideTooltip() {
            document.getElementById('tooltip').style.display = 'none';
        }
        
        function showDetail(link) {
            const rowData = findRows(link);
            
            if (rowData.length > 0) {
                const parsed = parseReference(link.getAttribute('data-ref'));
                const table = document.getElementById(parsed.tableId);
                const headers = Array.from(table.querySelectorAll('th'));
                
                let html = '';
                
                // Clear previous highlights
                document.querySelectorAll('tbody tr').forEach(tr => tr.classList.remove('highlight'));
                document.querySelectorAll('tbody td').forEach(td => td.classList.remove('highlight-cell'));
                
                // Determine column header name for display
                let columnHeaderName = 'Text'; // Default
                if (parsed.colNums && parsed.colNums.length > 0) {
                    const headerNames = parsed.colNums.map(colNum => headers[colNum - 1]?.textContent || `Column ${colNum}`);
                    columnHeaderName = headerNames.join(', ');
                } else if (parsed.allCols) {
                    columnHeaderName = 'All Columns';
                }
                
                // Check if we have continuous groups
                if (parsed.hasContinuous && parsed.continuousGroups.length > 0) {
                    // Process items respecting continuous groups
                    // Items in same continuous group go on same line
                    // Items separated by + go on different lines
                    
                    html += `<div class="detail-group">
                        <div class="detail-group-title">${columnHeaderName}</div>`;
                    
                    let currentIndex = 0;
                    
                    for (let i = 0; i < rowData.length; i++) {
                        const { row, value } = rowData[i];
                        const cells = row.querySelectorAll('td');
                        
                        // Highlight row
                        row.classList.add('highlight');
                        
                        // Highlight specific cells if columns specified, or all columns if requested
                        if (parsed.colNums) {
                            for (const colNum of parsed.colNums) {
                                const cellIndex = colNum - 1;
                                if (cells[cellIndex]) {
                                    cells[cellIndex].classList.add('highlight-cell');
                                }
                            }
                        } else if (parsed.allCols) {
                            Array.from(cells).forEach(c => c.classList.add('highlight-cell'));
                        }
                        
                        // Check if this index is part of a continuous group
                        const continuousGroup = parsed.continuousGroups.find(g => i >= g.start && i <= g.end);
                        
                        if (continuousGroup && i === continuousGroup.start) {
                            // Start of a continuous group - collect all items in this group
                            const groupContents = [];
                            for (let j = continuousGroup.start; j <= continuousGroup.end; j++) {
                                const groupRow = rowData[j].row;
                                const groupCells = groupRow.querySelectorAll('td');
                                
                                if (parsed.colNums) {
                                    for (const colNum of parsed.colNums) {
                                        const cellIndex = colNum - 1;
                                        groupContents.push(groupCells[cellIndex]?.textContent || 'N/A');
                                    }
                                } else if (parsed.allCols) {
                                    // Push all columns for this row
                                    for (let k = 0; k < groupCells.length; k++) {
                                        groupContents.push(groupCells[k]?.textContent || 'N/A');
                                    }
                                } else {
                                    groupContents.push(groupCells[1]?.textContent || 'N/A');
                                }
                            }
                            
                            html += `<div class="detail-row highlighted">
                                <span>${groupContents.join(' ')}</span>
                            </div>`;
                            
                            // Skip to end of this group
                            i = continuousGroup.end;
                        } else if (!continuousGroup) {
                            // Not part of any continuous group - display on its own line
                            const contentParts = [];
                            if (parsed.colNums) {
                                for (const colNum of parsed.colNums) {
                                    const cellIndex = colNum - 1;
                                    contentParts.push(cells[cellIndex]?.textContent || 'N/A');
                                }
                            } else if (parsed.allCols) {
                                for (let k = 0; k < cells.length; k++) {
                                    contentParts.push(cells[k]?.textContent || 'N/A');
                                }
                            } else {
                                contentParts.push(cells[1]?.textContent || 'N/A');
                            }
                            
                            html += `<div class="detail-row highlighted">
                                <span>${contentParts.join(' ')}</span>
                            </div>`;
                        }
                        // If inside a continuous group but not at start, skip (handled above)
                    }
                    
                    html += '</div>';
                } else {
                    // Normal display - separate groups for each row
                    for (const { row, value } of rowData) {
                        const cells = row.querySelectorAll('td');
                        
                        // Highlight row
                        row.classList.add('highlight');
                        
                        // Highlight specific cells if columns specified (or all columns if requested)
                        if (parsed.colNums) {
                            for (const colNum of parsed.colNums) {
                                const cellIndex = colNum - 1;
                                if (cells[cellIndex]) {
                                    cells[cellIndex].classList.add('highlight-cell');
                                }
                            }
                        } else if (parsed.allCols) {
                            Array.from(cells).forEach(c => c.classList.add('highlight-cell'));
                        }
                        
                        html += `<div class="detail-group">
                            <div class="detail-group-title">${cells[0].textContent}</div>`;
                        
                        if (parsed.colNums !== null) {
                            // Show only specified columns
                            for (const colNum of parsed.colNums) {
                                const cellIndex = colNum - 1;
                                const cellContent = cells[cellIndex]?.textContent || 'N/A';
                                const headerName = headers[cellIndex]?.textContent || `Column ${colNum}`;
                                
                                html += `<div class="detail-row highlighted">
                                    <span class="detail-label">${headerName}:</span>
                                    ${cellContent}
                                </div>`;
                            }
                        } else {
                            // Show all columns
                            for (let i = 0; i < cells.length; i++) {
                                html += `
                                    <div class="detail-row">
                                        <span class="detail-label">${headers[i].textContent}:</span>
                                        ${cells[i].textContent}
                                    </div>
                                `;
                            }
                        }
                        html += '</div>';
                    }
                }
                
                // Set title based on reference type
                let title = '';
                if (parsed.hasContinuous) {
                    title = `${columnHeaderName}: ${rowData.map(r => r.value).join(', ')}`;
                } else if (rowData.length === 1 && (!parsed.colNums || parsed.colNums.length === 1)) {
                    title = `Details: ${rowData[0].value}`;
                } else if (rowData.length === 1) {
                    title = `${rowData[0].value} - Selected Columns`;
                } else if (!parsed.colNums || parsed.colNums.length === 1) {
                    title = `Comparison: ${rowData.map(r => r.value).join(' & ')}`;
                } else {
                    title = `Multi-Row Multi-Column: ${rowData.map(r => r.value).join(' & ')}`;
                }
                
                document.getElementById('detailTitle').textContent = title;
                document.getElementById('detailContent').innerHTML = html;
                
                document.getElementById('overlay').classList.add('active');
                document.getElementById('detailPanel').classList.add('active');
            }
        }
        
        function closeDetail() {
            document.getElementById('overlay').classList.remove('active');
            document.getElementById('detailPanel').classList.remove('active');
            document.querySelectorAll('tbody tr').forEach(tr => tr.classList.remove('highlight'));
            document.querySelectorAll('tbody td').forEach(td => td.classList.remove('highlight-cell'));
        }
        
        // Initialize
        initPyodide().then(() => {
            console.log('System ready');
            // Auto-link all elements with auto-link-refs class after Pyodide loads
            document.querySelectorAll('.auto-link-refs').forEach(el => {
                autoLinkReferences(el);
            });
        });
        
        // Auto-detect and convert I(...) and R(...) patterns to links
        function autoLinkReferences(container) {
            // Process text nodes only to avoid breaking existing HTML
            const walker = document.createTreeWalker(
                container,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );
            
            const textNodes = [];
            while (walker.nextNode()) {
                textNodes.push(walker.currentNode);
            }
            
            // Regex to match I(...) or R(...) patterns
            const refPattern = /([IR]\([^)]+\))/g;
            
            textNodes.forEach(textNode => {
                const text = textNode.textContent;
                if (refPattern.test(text)) {
                    // Reset regex lastIndex
                    refPattern.lastIndex = 0;
                    
                    const fragment = document.createDocumentFragment();
                    let lastIndex = 0;
                    let match;
                    
                    while ((match = refPattern.exec(text)) !== null) {
                        // Add text before match
                        if (match.index > lastIndex) {
                            fragment.appendChild(document.createTextNode(text.slice(lastIndex, match.index)));
                        }
                        
                        // Create link for the reference
                        const link = document.createElement('a');
                        link.className = 'link';
                        link.setAttribute('data-ref', match[1]);
                        link.textContent = match[1];
                        link.href = '#';
                        fragment.appendChild(link);
                        
                        lastIndex = match.index + match[0].length;
                    }
                    
                    // Add remaining text
                    if (lastIndex < text.length) {
                        fragment.appendChild(document.createTextNode(text.slice(lastIndex)));
                    }
                    
                    // Replace the text node with the fragment
                    textNode.parentNode.replaceChild(fragment, textNode);
                }
            });
            
            // Re-attach event listeners to new links
            setupEventListeners();
        }
        
        // Load and render markdown content from external file
        async function loadMarkdownFile(url, targetElementId) {
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`Failed to load ${url}`);
                const markdown = await response.text();
                renderMarkdown(markdown, targetElementId);
            } catch (error) {
                console.error('Error loading markdown file:', error);
            }
        }
        
        // Load and execute external JS file containing text
        async function loadTextFile(url, targetElementId) {
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`Failed to load ${url}`);
                const text = await response.text();
                
                const targetElement = document.getElementById(targetElementId);
                if (targetElement) {
                    targetElement.innerHTML = text;
                    autoLinkReferences(targetElement);
                }
            } catch (error) {
                console.error('Error loading text file:', error);
            }
        }
        
        // Enhanced markdown to HTML converter with full support
        function renderMarkdown(markdown, targetElementId) {
            const targetElement = document.getElementById(targetElementId);
            if (!targetElement) return;
            
            let html = markdown
                // Code blocks (``` ```)
                .replace(/```(\w*)\n([\s\S]*?)```/g, '<pre><code class="language-$1">$2</code></pre>')
                // Inline code
                .replace(/`([^`]+)`/g, '<code>$1</code>')
                // Headers (must be before other processing)
                .replace(/^#### (.*$)/gim, '<h4>$1</h4>')
                .replace(/^### (.*$)/gim, '<h3>$1</h3>')
                .replace(/^## (.*$)/gim, '<h2>$1</h2>')
                .replace(/^# (.*$)/gim, '<h1>$1</h1>')
                // Horizontal rule
                .replace(/^---$/gim, '<hr>')
                // Bold and Italic combined
                .replace(/\*\*\*(.*?)\*\*\*/g, '<strong><em>$1</em></strong>')
                // Bold
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/__(.*?)__/g, '<strong>$1</strong>')
                // Italic
                .replace(/\*(.*?)\*/g, '<em>$1</em>')
                .replace(/_(.*?)_/g, '<em>$1</em>')
                // Strikethrough
                .replace(/~~(.*?)~~/g, '<del>$1</del>')
                // Blockquotes
                .replace(/^> (.*$)/gim, '<blockquote>$1</blockquote>')
                // Unordered lists
                .replace(/^\s*[-*+] (.*$)/gim, '<li>$1</li>')
                // Ordered lists
                .replace(/^\s*\d+\. (.*$)/gim, '<li>$1</li>')
                // Links [text](url)
                .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank">$1</a>')
                // Images ![alt](url)
                .replace(/!\[([^\]]*)\]\(([^)]+)\)/g, '<img src="$2" alt="$1" style="max-width:100%">')
                // Line breaks / paragraphs
                .replace(/\n\n+/g, '</p><p>')
                .replace(/\n/g, '<br>');
            
            // Wrap consecutive <li> in <ul>
            html = html.replace(/(<li>.*<\/li>)/gs, '<ul>$1</ul>');
            // Clean up multiple <ul> tags
            html = html.replace(/<\/ul>\s*<ul>/g, '');
            
            // Wrap consecutive blockquotes
            html = html.replace(/(<blockquote>.*<\/blockquote>)/gs, function(match) {
                return match.replace(/<\/blockquote>\s*<blockquote>/g, '<br>');
            });
            
            // Wrap in paragraph tags
            html = '<p>' + html + '</p>';
            
            // Clean up empty paragraphs
            html = html.replace(/<p>\s*<\/p>/g, '');
            html = html.replace(/<p>\s*(<h[1-6]>)/g, '$1');
            html = html.replace(/(<\/h[1-6]>)\s*<\/p>/g, '$1');
            html = html.replace(/<p>\s*(<ul>)/g, '$1');
            html = html.replace(/(<\/ul>)\s*<\/p>/g, '$1');
            html = html.replace(/<p>\s*(<pre>)/g, '$1');
            html = html.replace(/(<\/pre>)\s*<\/p>/g, '$1');
            html = html.replace(/<p>\s*(<hr>)\s*<\/p>/g, '$1');
            html = html.replace(/<p>\s*(<blockquote>)/g, '$1');
            html = html.replace(/(<\/blockquote>)\s*<\/p>/g, '$1');
            
            targetElement.innerHTML = html;
            autoLinkReferences(targetElement);
        }
        
        // Process inline text and return HTML with auto-linked references
        function processInlineText(text) {
            const refPattern = /([IR]\([^)]+\))/g;
            return text.replace(refPattern, '<a class="link" data-ref="$1" href="#">$1</a>');
        }
        
        // Process content on page load - auto-link any existing content
        document.addEventListener('DOMContentLoaded', () => {
            // Auto-link references in any element with class 'auto-link-refs'
            document.querySelectorAll('.auto-link-refs').forEach(el => {
                autoLinkReferences(el);
            });
            
            // Demo: Load sample markdown content
            const sampleMarkdown = `
# Sample Markdown Document

This document demonstrates **markdown support** with *automatic reference linking*.

## Validation Results

The validation process reviewed entry I(1,1.0) successfully. Item I(1,2.a) showed improvement. Test I(1,3.0.a.P) needs review.

### Status Summary

- Check status: R(1,2,3)
- Compare results: I(2,001+002,3)
- Full range: R(1,1-3,3)

## Experiment Data

> The experiments I(2,001-003,3) showed promising results across all test groups.

For detailed comparison, see I(2,001+002,3+4) which includes both Result and Remark columns.

---

**Note:** All references like R(2,1+2+3) are automatically converted to clickable links!
`;
            renderMarkdown(sampleMarkdown, 'markdownContent');
        });
        
        // Detect and render tables defined on window by external JS files (e.g., datanoteU14.js) ðŸ”§
        function detectAndRenderTablesFromWindow() {
            const container = document.querySelector('.container');
            if (!container) return;

            function extractFirstJsonArrayFrom(str, startIdx) {
                // Find matching bracket for the first '[' at or after startIdx
                const idx = str.indexOf('[', startIdx);
                if (idx === -1) return null;
                let depth = 0;
                for (let i = idx; i < str.length; i++) {
                    const ch = str[i];
                    if (ch === '[') depth++;
                    else if (ch === ']') {
                        depth--;
                        if (depth === 0) {
                            return str.slice(idx, i + 1);
                        }
                    }
                }
                return null;
            }

            for (const key of Object.keys(window)) {
                try {
                    const val = window[key];
                    if (val === undefined || val === null) continue;

                    // Case A: string that contains markers like "#Table14:Title" followed by JSON
                    if (typeof val === 'string') {
                        const regex = /#\s*Table\s*(\d+)\s*:\s*([^\n\r]+)/gi;
                        let m;
                        while ((m = regex.exec(val)) !== null) {
                            const tableNum = m[1];
                            const title = m[2].trim();
                            const jsonPart = extractFirstJsonArrayFrom(val, regex.lastIndex);
                            if (jsonPart) {
                                try {
                                    const data = JSON.parse(jsonPart);
                                    registerTableFromJSON(tableNum, title, data, container);
                                } catch (e) {
                                    // ignore parse errors for that block
                                }
                            }
                        }
                    }

                    // Case B: arrays assigned directly e.g., window.table14 = [{...}]
                    else if (Array.isArray(val)) {
                        const m2 = key.match(/table\s*(\d+)/i) || key.match(/^table(\d+)/i);
                        let tableNum = null;
                        if (m2) tableNum = m2[1];
                        if (tableNum) {
                            const title = (window[key + 'Title'] || window[key + 'Name'] || key).toString();
                            registerTableFromJSON(tableNum, title, val, container);
                        }
                    }
                } catch (err) {
                    // ignore access/parse errors and continue
                }
            }

            // Re-run auto-linking on all auto-link-refs and event listeners to ensure interactivity
            document.querySelectorAll('.auto-link-refs').forEach(el => autoLinkReferences(el));
            setupEventListeners();
        }

        function registerTableFromJSON(tableNum, title, dataArray, container) {
            const tableId = 'T' + tableNum;
            if (document.getElementById(tableId)) return; // do not duplicate
            if (!Array.isArray(dataArray) || dataArray.length === 0) return;

            const section = document.createElement('div');
            section.className = 'table-section';

            const h3 = document.createElement('h3');
            h3.textContent = `Table ${tableNum}: ${title}`;
            section.appendChild(h3);

            const table = document.createElement('table');
            table.id = tableId;

            // Headers from first object's keys (preserve insertion order)
            const first = dataArray[0];
            const headers = Object.keys(first);

            const thead = document.createElement('thead');
            const trh = document.createElement('tr');
            headers.forEach(h => {
                const th = document.createElement('th');
                th.textContent = h;
                trh.appendChild(th);
            });
            thead.appendChild(trh);
            table.appendChild(thead);

            const tbody = document.createElement('tbody');
            dataArray.forEach(obj => {
                const tr = document.createElement('tr');
                headers.forEach(h => {
                    const td = document.createElement('td');
                    td.textContent = obj[h] !== undefined ? obj[h] : '';
                    tr.appendChild(td);
                });
                tbody.appendChild(tr);
            });
            table.appendChild(tbody);

            section.appendChild(table);

            // Insert before the legend if present to keep main content order, otherwise append
            const legend = document.querySelector('.legend');
            if (legend && legend.parentNode) {
                legend.parentNode.insertBefore(section, legend);
            } else {
                container.appendChild(section);
            }
        }

        // Internal registry for tables (includes inline and external)
        window.TableRefSystem = window.TableRefSystem || {};
        window.TableRefSystem._registeredTables = window.TableRefSystem._registeredTables || [];

        function addRegisteredTable(tableId, title, sectionEl) {
            // Avoid duplicates
            if (window.TableRefSystem._registeredTables.find(r => r.tableId === tableId)) return;
            window.TableRefSystem._registeredTables.push({ tableId, title, sectionEl });
            updateTableListUI();
        }

        function refreshDropdownSummary() {
            const btn = document.getElementById('tableDropdownBtn');
            const list = document.getElementById('tableList');
            if (!btn || !list) return;
            const total = list.querySelectorAll('.table-option input[type="checkbox"]:not(#tableAllCheckbox)').length;
            const checked = list.querySelectorAll('.table-option input[type="checkbox"]:not(#tableAllCheckbox):checked').length;
            if (total === 0) btn.textContent = 'No tables';
            else if (checked === 0) btn.textContent = 'Select tables â–¾';
            else if (checked === total) btn.textContent = `All (${checked}) â–¾`;
            else btn.textContent = `Selected: ${checked} â–¾`;
        }

        function updateTableListUI() {
            const list = document.getElementById('tableList');
            if (!list) return;
            // Preserve current selections
            const prevSelected = new Set(Array.from(list.querySelectorAll('.table-option input[type="checkbox"]:not(#tableAllCheckbox):checked')).map(i => i.getAttribute('data-table')));

            // Clear
            list.innerHTML = '';

            // Create All option at the top
            const allDiv = document.createElement('div');
            allDiv.className = 'table-option';
            allDiv.innerHTML = `<input type="checkbox" id="tableAllCheckbox"> <label for="tableAllCheckbox"><strong>All</strong></label>`;
            list.appendChild(allDiv);

            for (const reg of window.TableRefSystem._registeredTables) {
                const div = document.createElement('div');
                div.className = 'table-option';
                div.innerHTML = `<input type="checkbox" id="chk_${reg.tableId}" data-table="${reg.tableId}"> <label for="chk_${reg.tableId}">${reg.title} (<code>${reg.tableId}</code>)</label>`;
                list.appendChild(div);

                // Restore previous checked state or default based on section visibility
                const chk = div.querySelector('input[type="checkbox"]');
                const isVisible = reg.sectionEl && !reg.sectionEl.classList.contains('hidden-table');
                chk.checked = prevSelected.has(reg.tableId) || isVisible;

                // Make the entire option clickable and prevent the dropdown from closing
                div.addEventListener('click', (e) => {
                    // If the actual input was clicked, let the change event handle it
                    if (e.target && e.target.tagName && e.target.tagName.toLowerCase() === 'input') return;
                    // Avoid toggling when clicking links or code elements inside label
                    if (e.target && (e.target.tagName.toLowerCase() === 'a' || e.target.tagName.toLowerCase() === 'code')) return;

                    const checkbox = div.querySelector('input[type="checkbox"]');
                    if (!checkbox) return;
                    checkbox.checked = !checkbox.checked;
                    checkbox.dispatchEvent(new Event('change', { bubbles: true }));
                    e.stopPropagation();
                });
            }

            // Attach event listeners for table checkboxes (exclude All)
            list.querySelectorAll('.table-option input[type="checkbox"]:not(#tableAllCheckbox)').forEach(chk => {
                // Remove duplicate handlers by replacing with a clone
                const newChk = chk.cloneNode(true);
                chk.parentNode.replaceChild(newChk, chk);
            });

            list.querySelectorAll('.table-option input[type="checkbox"]:not(#tableAllCheckbox)').forEach(chk => {
                chk.addEventListener('change', (e) => {
                    const tableId = chk.getAttribute('data-table');
                    toggleTableVisibility(tableId, chk.checked);
                    // Update All checkbox state based on table checkboxes only
                    const total = list.querySelectorAll('.table-option input[type="checkbox"]:not(#tableAllCheckbox)').length;
                    const checked = list.querySelectorAll('.table-option input[type="checkbox"]:not(#tableAllCheckbox):checked').length;
                    const allChk = document.getElementById('tableAllCheckbox');
                    if (allChk) allChk.checked = (total === checked && total > 0);

                    // Refresh summary
                    refreshDropdownSummary();
                });
            });

            // Setup All checkbox change handler
            const allChk = document.getElementById('tableAllCheckbox');
            if (allChk) {
                // Make label clicks also toggle All reliably
                const allLabel = list.querySelector('label[for="tableAllCheckbox"]');
                if (allLabel) {
                    allLabel.addEventListener('click', (e) => {
                        e.preventDefault(); // prevent any default double handling
                        allChk.checked = !allChk.checked;
                        allChk.dispatchEvent(new Event('change'));
                    });
                }

                allChk.addEventListener('change', () => {
                    const tableChks = list.querySelectorAll('.table-option input[type="checkbox"]:not(#tableAllCheckbox)');
                    tableChks.forEach(c => {
                        c.checked = allChk.checked;
                        c.dispatchEvent(new Event('change'));
                    });
                    refreshDropdownSummary();
                });

                // Sync All checkbox with current table checkboxes
                const total = list.querySelectorAll('.table-option input[type="checkbox"]:not(#tableAllCheckbox)').length;
                const checked = list.querySelectorAll('.table-option input[type="checkbox"]:not(#tableAllCheckbox):checked').length;
                allChk.checked = (total === checked && total > 0);

                if (allChk.checked) {
                    list.querySelectorAll('.table-option input[type="checkbox"]:not(#tableAllCheckbox)').forEach(c => {
                        if (!c.checked) {
                            c.checked = true;
                            c.dispatchEvent(new Event('change'));
                        }
                    });
                }
            }

            // Refresh dropdown button text
            refreshDropdownSummary();
        }

        function toggleTableVisibility(tableId, visible) {
            const reg = window.TableRefSystem._registeredTables.find(r => r.tableId === tableId);
            if (!reg || !reg.sectionEl) return;
            if (visible) reg.sectionEl.classList.remove('hidden-table');
            else reg.sectionEl.classList.add('hidden-table');
        }

        function collectInlineTables() {
            // Find existing .table-section blocks with table ids
            const sections = document.querySelectorAll('.table-section');
            sections.forEach(sec => {
                const table = sec.querySelector('table');
                if (!table || !table.id) return;
                const titleEl = sec.querySelector('h3');
                const title = titleEl ? titleEl.textContent.trim() : table.id;
                // Hide by default
                sec.classList.add('hidden-table');
                addRegisteredTable(table.id, title, sec);
            });
        }

        function initTableSelector() {
            const wrapper = document.getElementById('tableDropdownWrapper');
            const btn = document.getElementById('tableDropdownBtn');
            const dropdown = document.getElementById('tableDropdown');

            if (!wrapper || !btn || !dropdown) return;

            btn.addEventListener('click', (e) => {
                wrapper.classList.toggle('open');
            });

            // Close on click outside
            document.addEventListener('click', (e) => {
                if (!wrapper.contains(e.target)) wrapper.classList.remove('open');
            });
        }

        // Patch registerTableFromJSON to hide tables by default and register them
        const _origRegisterTableFromJSON = registerTableFromJSON;
        registerTableFromJSON = function(tableNum, title, dataArray, container) {
            _origRegisterTableFromJSON(tableNum, title, dataArray, container);
            const tableId = 'T' + tableNum;
            const sec = document.getElementById(tableId)?.closest('.table-section') || document.getElementById(tableId)?.parentElement;
            const sectionEl = document.getElementById(tableId)?.closest('.table-section');
            if (sectionEl) {
                sectionEl.classList.add('hidden-table');
                addRegisteredTable(tableId, `Table ${tableNum}: ${title}`, sectionEl);
            }
        };

        // Ensure inline tables are collected and UI initialized after DOM ready
        document.addEventListener('DOMContentLoaded', () => {
            collectInlineTables();
            initTableSelector();
            updateTableListUI();
        });

        // Ensure we re-populate list after external tables are registered
        const _origDetect = detectAndRenderTablesFromWindow;
        detectAndRenderTablesFromWindow = function() {
            _origDetect();
            // After registering external tables, collect their sections and add to list
            window.TableRefSystem._registeredTables.forEach(r => {
                const sec = document.getElementById(r.tableId)?.closest('.table-section');
                if (sec) {
                    sec.classList.add('hidden-table');
                    r.sectionEl = sec;
                }
            });
            updateTableListUI();
        };

        // Expose functions globally for external use
        window.TableRefSystem = Object.assign(window.TableRefSystem, {
            autoLinkReferences,
            loadMarkdownFile,
            loadTextFile,
            renderMarkdown,
            processInlineText,
            registerWindowTables: detectAndRenderTablesFromWindow,
            registerTableFromJSON,
            addRegisteredTable,
            _registeredTables: window.TableRefSystem._registeredTables
        });
    </script>
          <script src="datanoteU14.js"></script>
          <script>
            // After loading external scripts, scan window for table definitions and render them.
            // Retry on load and after a short delay to cover timing edge-cases where scripts run slightly later.
            function tryRegisterWindowTables() {
                if (window.TableRefSystem && typeof window.TableRefSystem.registerWindowTables === 'function') {
                    window.TableRefSystem.registerWindowTables();
                }
            }
            tryRegisterWindowTables();
            window.addEventListener('load', tryRegisterWindowTables);
            setTimeout(tryRegisterWindowTables, 250);
          </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Table Reference System</title>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.23.4/full/pyodide.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Arial, sans-serif;
            background: #f0f2f5;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 30px;
        }
        
        h1 {
            color: #333;
            margin-bottom: 20px;
        }
        
        .narrative {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
            line-height: 1.8;
        }
        
        .narrative h2 {
            color: #555;
            margin-bottom: 15px;
            font-size: 1.3em;
        }
        
        .narrative h4 {
            color: #666;
            margin: 15px 0 10px 0;
            font-size: 1em;
        }
        
        .link {
            color: #0066cc;
            text-decoration: none;
            font-weight: bold;
            cursor: pointer;
            border-bottom: 1px dotted #0066cc;
        }
        
        .link:hover {
            background: #e6f2ff;
            padding: 2px 4px;
            border-radius: 3px;
        }
        
        .tooltip {
            position: fixed;
            background: #333;
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 0.9em;
            max-width: 500px;
            z-index: 1000;
            display: none;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
        
        .tooltip-item {
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid #555;
        }
        
        .tooltip-item:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }
        
        .tooltip-row-label {
            color: #7cb3ff;
            font-weight: bold;
            margin-bottom: 4px;
        }
        
        .tooltip-col {
            margin-left: 10px;
            margin-top: 3px;
        }
        
        .tooltip-col-label {
            color: #aaa;
            font-size: 0.85em;
        }
        
        .table-section {
            margin-bottom: 30px;
        }
        
        .table-section h3 {
            color: #555;
            margin-bottom: 10px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        
        th, td {
            padding: 10px;
            text-align: left;
            border: 1px solid #ddd;
        }
        
        th {
            background: #0066cc;
            color: white;
        }
        
        tr:hover {
            background: #f5f5f5;
        }
        
        tr.highlight {
            background: #fff3cd !important;
        }
        
        td.highlight-cell {
            background: #ffe066 !important;
            font-weight: bold;
        }
        
        .detail-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            max-width: 700px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 2000;
            display: none;
        }
        
        .detail-panel.active {
            display: block;
        }
        
        .detail-panel h3 {
            color: #333;
            margin-bottom: 15px;
        }
        
        .detail-group {
            margin-bottom: 20px;
            padding: 15px;
            background: #f0f4f8;
            border-radius: 8px;
            border-left: 4px solid #0066cc;
        }
        
        .detail-group-title {
            font-weight: bold;
            color: #0066cc;
            margin-bottom: 10px;
            font-size: 1.1em;
        }
        
        .detail-row {
            margin-bottom: 10px;
            padding: 8px;
            background: white;
            border-radius: 5px;
        }
        
        .detail-row.highlighted {
            background: #fff3cd;
            border: 1px solid #ffc107;
        }
        
        .detail-label {
            font-weight: bold;
            color: #0066cc;
        }
        
        .close-btn {
            background: #0066cc;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            float: right;
        }
        
        .close-btn:hover {
            background: #0052a3;
        }
        
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1500;
            display: none;
        }
        
        .overlay.active {
            display: block;
        }
        
        .legend {
            background: #e8f4f8;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            font-size: 0.9em;
        }
        
        .legend h4 {
            margin-bottom: 10px;
            color: #333;
        }
        
        .legend code {
            background: #d4e8f0;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
        }
        
        /* Markdown content styles */
        .narrative h1, .narrative h2, .narrative h3, .narrative h4 {
            margin-top: 15px;
            margin-bottom: 10px;
        }
        
        .narrative ul, .narrative ol {
            margin: 10px 0;
            padding-left: 25px;
        }
        
        .narrative li {
            margin: 5px 0;
        }
        
        .narrative blockquote {
            border-left: 4px solid #0066cc;
            margin: 15px 0;
            padding: 10px 15px;
            background: #e6f2ff;
            border-radius: 0 5px 5px 0;
        }
        
        .narrative pre {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
        }
        
        .narrative code {
            background: #e8e8e8;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        .narrative pre code {
            background: none;
            padding: 0;
        }
        
        .narrative hr {
            border: none;
            border-top: 2px solid #ddd;
            margin: 20px 0;
        }
        
        .narrative img {
            max-width: 100%;
            border-radius: 5px;
            margin: 10px 0;
        }
        
        .narrative a:not(.link) {
            color: #0066cc;
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸ“Š Interactive Table Reference System</h1>
        
        <div class="narrative">
            <h2>Project Summary</h2>
            
            <h4>Basic References (Single Row, Single/No Column)</h4>
            <p class="auto-link-refs">
                The validation process reviewed entry I(1,1.0) successfully. Item I(1,2.a) showed improvement. Test I(1,3.0.a.P) needs review. Check the status: R(1,2,3).
            </p>
            
            <h4>Single Row, Multiple Columns</h4>
            <p class="auto-link-refs">
                View ID and Status for row 1: I(1,1.0,1+3). See Text, Status, Remark: R(1,1,2+3+4). Experiment 001 Result & Remark: I(2,001,3+4).
            </p>
            
            <h4>Multiple Rows, Single Column</h4>
            <p class="auto-link-refs">
                Compare results I(2,001+002,3) for analysis. See rows R(1,1+2,3) status comparison. All experiment IDs: R(2,1+2+3,1).
            </p>
            
            <h4>Range Syntax (Using -)</h4>
            <p class="auto-link-refs">
                Rows 1-3, Status column: R(1,1-3,3). IDs 001-003, Result column: I(2,001-003,3). Row 1, Columns 2-4: R(1,1,2-4). Mixed: R(2,1-3,3+4) and I(2,001-002,2-4).
            </p>
            
            <h4>Continuous Display (Using *)</h4>
            <p class="auto-link-refs">
                Combined text from IDs 1.0 and 2.a: I(1,1.0*2.a*3.0.a.P,2). All statuses in one line: R(1,1*2*3,3). Mixed (1.0*2.a on one line, 3.0.a.P on new line): I(1,1.0*2.a+3.0.a.P,2).
            </p>
            
            <h4>Multiple Rows, Multiple Columns</h4>
            <p class="auto-link-refs">
                Full comparison 001 & 002 (Result + Remark): I(2,001+002,3+4). Table 1 rows 1-3 (Status + Remark): R(1,1+2+3,3+4). All experiments (ID + Result): I(2,001+002+003,1+3).
            </p>
            
            <h4>Full Row References (No Column Specified)</h4>
            <p class="auto-link-refs">
                Full details: I(2,001+002+003). Row comparison: R(2,1+2+3).
            </p>
        </div>
        
        <div class="table-section">
            <h3>Table 1: Validation Results</h3>
            <table id="T1">
                <thead>
                    <tr>
                        <th>ID</th>
                        <th>Text</th>
                        <th>Status</th>
                        <th>Remark</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>1.0</td>
                        <td>Primary validation completed</td>
                        <td>Passed</td>
                        <td>All criteria met</td>
                    </tr>
                    <tr>
                        <td>2.a</td>
                        <td>Performance metrics improved</td>
                        <td>Passed</td>
                        <td>20% increase over baseline</td>
                    </tr>
                    <tr>
                        <td>3.0.a.P</td>
                        <td>Testing phase insights</td>
                        <td>Review</td>
                        <td>Additional analysis needed</td>
                    </tr>
                </tbody>
            </table>
        </div>
        
        <div class="table-section">
            <h3>Table 2: Experiment Data</h3>
            <table id="T2">
                <thead>
                    <tr>
                        <th>ID</th>
                        <th>Text</th>
                        <th>Result</th>
                        <th>Remark</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>001</td>
                        <td>Promising experimental results</td>
                        <td>Positive</td>
                        <td>Exceeded performance by 15%</td>
                    </tr>
                    <tr>
                        <td>002</td>
                        <td>Sample requiring verification</td>
                        <td>Pending</td>
                        <td>Secondary validation scheduled</td>
                    </tr>
                    <tr>
                        <td>003</td>
                        <td>Control group baseline</td>
                        <td>Stable</td>
                        <td>Consistent performance</td>
                    </tr>
                </tbody>
            </table>
        </div>
        
        <div class="legend">
            <h4>Reference Syntax Guide</h4>
            <p><code>I(table, id)</code> - Reference by ID value</p>
            <p><code>R(table, row)</code> - Reference by row number</p>
            <p><code>I(table, id, col)</code> - Single row, single column</p>
            <p><code>I(table, id, col1+col2)</code> - Single row, multiple columns (using +)</p>
            <p><code>I(table, id1+id2, col)</code> - Multiple rows, single column (using +) - separate lines</p>
            <p><code>I(table, id1+id2, col1+col2)</code> - Multiple rows, multiple columns</p>
            <p><code>R(table, row1-row3, col)</code> - Row range (using -), e.g., 1-3 = rows 1,2,3</p>
            <p><code>I(table, id1-id3, col1-col3)</code> - ID range and column range</p>
            <p><code>R(table, 1-3+5, 2-4)</code> - Mixed: range + individual values</p>
            <p><code>I(table, id1*id2, col)</code> - Continuous display (using *) - content on same line</p>
            <p><code>I(table, id1*id2+id3, col)</code> - Mixed: id1*id2 on one line, id3 on new line</p>
        </div>
        
        <div class="narrative" style="margin-top: 20px;">
            <h2>Auto-Linked Content Demo</h2>
            <div id="autoLinkedDemo" class="auto-link-refs">
                This text has auto-detected references: The experiment R(2,1-3,3) shows positive results. Compare I(1,1.0) with I(1,2.a) for validation insights. Full data available at I(2,001-003,1+3).
            </div>
        </div>
        
        <div class="narrative" style="margin-top: 20px;">
            <h2>External Content Container</h2>
            <div id="externalContent" class="auto-link-refs">
                <!-- Content from text1.js, text2.js or markdown files will be loaded here -->
                <p style="color: #888; font-style: italic;">Use TableRefSystem.loadTextFile('text1.js', 'externalContent') or TableRefSystem.renderMarkdown(markdownString, 'externalContent') to load content.</p>
            </div>
        </div>
        
        <div class="narrative" style="margin-top: 20px;">
            <h2>Markdown Content Container</h2>
            <div id="markdownContent"></div>
        </div>
    </div>
    
    <div class="tooltip" id="tooltip"></div>
    <div class="overlay" id="overlay"></div>
    <div class="detail-panel" id="detailPanel">
        <button class="close-btn" onclick="closeDetail()">Close</button>
        <h3 id="detailTitle">Details</h3>
        <div id="detailContent"></div>
    </div>
    
    <script>
        let pyodide;
        
        async function initPyodide() {
            pyodide = await loadPyodide();
            
            await pyodide.runPythonAsync(`
def get_row_by_id(table_id, row_id):
    """Find row by ID value"""
    return {'table': table_id, 'id': row_id, 'type': 'id'}

def get_row_by_number(table_id, row_num):
    """Find row by row number (1-indexed)"""
    return {'table': table_id, 'row': row_num, 'type': 'row'}
            `);
            
            setupEventListeners();
        }
        
        function setupEventListeners() {
            const links = document.querySelectorAll('.link');
            
            links.forEach(link => {
                link.addEventListener('mouseenter', (e) => showTooltip(e, link));
                link.addEventListener('mouseleave', hideTooltip);
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    showDetail(link);
                });
            });
            
            document.getElementById('overlay').addEventListener('click', closeDetail);
        }
        
        function expandRange(str, isNumeric = true) {
            // Expand range syntax: "1-3" becomes ["1","2","3"], "001-003" becomes ["001","002","003"]
            // Also handles + syntax: "1+2+3" or mixed "1-3+5"
            // Also handles * syntax: "1.0*2.a" for continuous display (returns object with flag)
            // Mixed: "1.0*2.a+3.0.a.P" means 1.0 and 2.a on same line, 3.0.a.P on new line
            
            // Split by + first to get separate line groups
            const plusParts = str.split('+').map(p => p.trim());
            const result = [];
            let continuousGroups = []; // Track which items should be displayed continuously
            
            for (const plusPart of plusParts) {
                if (plusPart.includes('*')) {
                    // This is a continuous group (items joined by *)
                    const continuousItems = plusPart.split('*').map(s => s.trim());
                    const groupStart = result.length;
                    
                    continuousItems.forEach(item => {
                        if (item.includes('-')) {
                            // Handle range within continuous group
                            const expanded = expandRangeSimple(item, isNumeric);
                            result.push(...expanded);
                        } else {
                            result.push(item);
                        }
                    });
                    
                    // Mark this group as continuous (start to end indices)
                    continuousGroups.push({ start: groupStart, end: result.length - 1 });
                } else if (plusPart.includes('-')) {
                    // Range without continuous - each item is separate
                    const expanded = expandRangeSimple(plusPart, isNumeric);
                    result.push(...expanded);
                } else {
                    // Single item
                    result.push(plusPart);
                }
            }
            
            const hasContinuous = continuousGroups.length > 0;
            
            return { values: result, continuousGroups, hasContinuous };
        }
        
        function expandRangeSimple(part, isNumeric) {
            // Simple range expansion helper
            const result = [];
            const [startStr, endStr] = part.split('-').map(s => s.trim());
            
            if (isNumeric) {
                // Numeric range (for row numbers or column numbers)
                const start = parseInt(startStr);
                const end = parseInt(endStr);
                // Preserve leading zeros if present
                const padLength = startStr.length;
                for (let i = start; i <= end; i++) {
                    result.push(String(i).padStart(padLength, '0'));
                }
            } else {
                // ID range - try to detect numeric suffix pattern
                const startMatch = startStr.match(/^(.*?)(\d+)$/);
                const endMatch = endStr.match(/^(.*?)(\d+)$/);
                
                if (startMatch && endMatch && startMatch[1] === endMatch[1]) {
                    // Same prefix, numeric suffix
                    const prefix = startMatch[1];
                    const startNum = parseInt(startMatch[2]);
                    const endNum = parseInt(endMatch[2]);
                    const padLength = startMatch[2].length;
                    
                    for (let i = startNum; i <= endNum; i++) {
                        result.push(prefix + String(i).padStart(padLength, '0'));
                    }
                } else {
                    // Can't expand, just add as-is
                    result.push(part);
                }
            }
            return result;
        }
        
        function parseReference(ref) {
            // Parse format: I(tableNum, id) or R(tableNum, rowNum) or with column(s)
            // Supports multiple values with + separator and - range for both rows and columns
            // Supports * for continuous display (no line breaks)
            // Examples: I(1,1.0), R(1,2), I(1,1.0,2), R(1,2,3), 
            //           I(2,001+002,3), R(1,1+2+3), I(1,1.0,1+3), I(2,001+002,3+4)
            //           R(1,1-3,3) - rows 1 to 3, column 3
            //           I(2,001-003,3+4) - IDs 001 to 003, columns 3 and 4
            //           I(1,1.0*2.a) - IDs 1.0 and 2.a displayed continuously
            const match = ref.match(/([IR])\((\d+),([^,\)]+)(?:,([^,\)]+))?\)/);
            if (!match) return null;
            
            const refType = match[1]; // 'I' for ID, 'R' for Row
            const tableNum = match[2];
            const valueStr = match[3].trim();
            const colStr = match[4] ? match[4].trim() : null; // Optional column(s)
            
            // Expand row values (handle both + and - and * syntax)
            const rowExpanded = expandRange(valueStr, refType === 'R');
            const rowValues = rowExpanded.values;
            const continuousGroups = rowExpanded.continuousGroups;
            const hasContinuous = rowExpanded.hasContinuous;
            
            // Expand column numbers (always numeric)
            let colNums = null;
            if (colStr) {
                const colExpanded = expandRange(colStr, true);
                colNums = colExpanded.values.map(c => parseInt(c));
            }
            
            // Get table by number (1-indexed)
            const tables = document.querySelectorAll('table');
            const tableId = tables[tableNum - 1]?.id;
            
            return { 
                tableId, 
                refType, 
                rowValues, 
                colNums,
                isMultiRow: rowValues.length > 1,
                isMultiCol: colNums && colNums.length > 1,
                continuousGroups,
                hasContinuous
            };
        }
        
        function findRow(tableId, refType, value) {
            const table = document.getElementById(tableId);
            if (!table) return null;
            
            const tbody = table.querySelector('tbody');
            
            if (refType === 'R') {
                // Row number reference
                const rowNum = parseInt(value);
                return tbody.rows[rowNum - 1]; // Convert to 0-indexed
            } else if (refType === 'I') {
                // ID reference - search for it in first column
                const rows = tbody.querySelectorAll('tr');
                for (let row of rows) {
                    if (row.cells[0].textContent === value) {
                        return row;
                    }
                }
            }
            
            return null;
        }
        
        function findRows(link) {
            const ref = link.getAttribute('data-ref');
            const parsed = parseReference(ref);
            if (!parsed) return [];
            
            const rows = [];
            for (const value of parsed.rowValues) {
                const row = findRow(parsed.tableId, parsed.refType, value);
                if (row) {
                    rows.push({ row, value });
                }
            }
            
            return rows;
        }
        
        function getHeaders(tableId) {
            const table = document.getElementById(tableId);
            if (!table) return [];
            return Array.from(table.querySelectorAll('th')).map(th => th.textContent);
        }
        
        function getCellContents(link) {
            const ref = link.getAttribute('data-ref');
            const parsed = parseReference(ref);
            const rowData = findRows(link);
            const headers = getHeaders(parsed.tableId);
            
            if (rowData.length === 0) return [];
            
            const contents = [];
            for (const { row, value } of rowData) {
                const rowContent = {
                    id: value,
                    columns: []
                };
                
                if (parsed.colNums !== null) {
                    // Specific column(s) requested
                    for (const colNum of parsed.colNums) {
                        const cellIndex = colNum - 1; // Convert to 0-indexed
                        rowContent.columns.push({
                            colNum: colNum,
                            header: headers[cellIndex] || `Column ${colNum}`,
                            content: row.cells[cellIndex]?.textContent || 'N/A'
                        });
                    }
                } else {
                    // Default: return Text column (column 2)
                    rowContent.columns.push({
                        colNum: 2,
                        header: headers[1] || 'Text',
                        content: row.cells[1]?.textContent || 'N/A'
                    });
                }
                
                contents.push(rowContent);
            }
            
            return contents;
        }
        
        function showTooltip(e, link) {
            const contents = getCellContents(link);
            const parsed = parseReference(link.getAttribute('data-ref'));
            
            if (contents.length > 0) {
                const tooltip = document.getElementById('tooltip');
                
                // Check if we have continuous groups with mixed + syntax
                if (parsed && parsed.hasContinuous && parsed.continuousGroups.length > 0) {
                    // Build tooltip respecting continuous groups
                    let html = '';
                    let i = 0;
                    
                    while (i < contents.length) {
                        const continuousGroup = parsed.continuousGroups.find(g => i >= g.start && i <= g.end);
                        
                        if (continuousGroup && i === continuousGroup.start) {
                            // Continuous group - join content on same line
                            const groupContent = [];
                            for (let j = continuousGroup.start; j <= continuousGroup.end; j++) {
                                groupContent.push(contents[j].columns.map(col => col.content).join(' '));
                            }
                            html += `<div class="tooltip-item">${groupContent.join(' ')}</div>`;
                            i = continuousGroup.end + 1;
                        } else if (!continuousGroup) {
                            // Not in continuous group - separate line
                            html += `<div class="tooltip-item">${contents[i].columns.map(col => col.content).join(' ')}</div>`;
                            i++;
                        } else {
                            i++;
                        }
                    }
                    tooltip.innerHTML = html;
                }
                // Single row, single column - simple display
                else if (contents.length === 1 && contents[0].columns.length === 1) {
                    tooltip.innerHTML = contents[0].columns[0].content;
                } 
                // Single row, multiple columns
                else if (contents.length === 1) {
                    let html = `<div class="tooltip-item">`;
                    for (const col of contents[0].columns) {
                        html += `<div class="tooltip-col">
                            <span class="tooltip-col-label">${col.header}:</span> ${col.content}
                        </div>`;
                    }
                    html += '</div>';
                    tooltip.innerHTML = html;
                }
                // Multiple rows
                else {
                    let html = '';
                    for (const item of contents) {
                        html += `<div class="tooltip-item">
                            <div class="tooltip-row-label">${item.id}</div>`;
                        for (const col of item.columns) {
                            html += `<div class="tooltip-col">
                                <span class="tooltip-col-label">${col.header}:</span> ${col.content}
                            </div>`;
                        }
                        html += '</div>';
                    }
                    tooltip.innerHTML = html;
                }
                
                tooltip.style.display = 'block';
                tooltip.style.left = Math.min(e.clientX, window.innerWidth - 520) + 'px';
                tooltip.style.top = (e.clientY + 20) + 'px';
            }
        }
        
        function hideTooltip() {
            document.getElementById('tooltip').style.display = 'none';
        }
        
        function showDetail(link) {
            const rowData = findRows(link);
            
            if (rowData.length > 0) {
                const parsed = parseReference(link.getAttribute('data-ref'));
                const table = document.getElementById(parsed.tableId);
                const headers = Array.from(table.querySelectorAll('th'));
                
                let html = '';
                
                // Clear previous highlights
                document.querySelectorAll('tbody tr').forEach(tr => tr.classList.remove('highlight'));
                document.querySelectorAll('tbody td').forEach(td => td.classList.remove('highlight-cell'));
                
                // Determine column header name for display
                let columnHeaderName = 'Text'; // Default
                if (parsed.colNums && parsed.colNums.length > 0) {
                    const headerNames = parsed.colNums.map(colNum => headers[colNum - 1]?.textContent || `Column ${colNum}`);
                    columnHeaderName = headerNames.join(', ');
                }
                
                // Check if we have continuous groups
                if (parsed.hasContinuous && parsed.continuousGroups.length > 0) {
                    // Process items respecting continuous groups
                    // Items in same continuous group go on same line
                    // Items separated by + go on different lines
                    
                    html += `<div class="detail-group">
                        <div class="detail-group-title">${columnHeaderName}</div>`;
                    
                    let currentIndex = 0;
                    
                    for (let i = 0; i < rowData.length; i++) {
                        const { row, value } = rowData[i];
                        const cells = row.querySelectorAll('td');
                        
                        // Highlight row
                        row.classList.add('highlight');
                        
                        // Highlight specific cells if columns specified
                        if (parsed.colNums) {
                            for (const colNum of parsed.colNums) {
                                const cellIndex = colNum - 1;
                                if (cells[cellIndex]) {
                                    cells[cellIndex].classList.add('highlight-cell');
                                }
                            }
                        }
                        
                        // Check if this index is part of a continuous group
                        const continuousGroup = parsed.continuousGroups.find(g => i >= g.start && i <= g.end);
                        
                        if (continuousGroup && i === continuousGroup.start) {
                            // Start of a continuous group - collect all items in this group
                            const groupContents = [];
                            for (let j = continuousGroup.start; j <= continuousGroup.end; j++) {
                                const groupRow = rowData[j].row;
                                const groupCells = groupRow.querySelectorAll('td');
                                
                                if (parsed.colNums) {
                                    for (const colNum of parsed.colNums) {
                                        const cellIndex = colNum - 1;
                                        groupContents.push(groupCells[cellIndex]?.textContent || 'N/A');
                                    }
                                } else {
                                    groupContents.push(groupCells[1]?.textContent || 'N/A');
                                }
                            }
                            
                            html += `<div class="detail-row highlighted">
                                <span>${groupContents.join(' ')}</span>
                            </div>`;
                            
                            // Skip to end of this group
                            i = continuousGroup.end;
                        } else if (!continuousGroup) {
                            // Not part of any continuous group - display on its own line
                            const contentParts = [];
                            if (parsed.colNums) {
                                for (const colNum of parsed.colNums) {
                                    const cellIndex = colNum - 1;
                                    contentParts.push(cells[cellIndex]?.textContent || 'N/A');
                                }
                            } else {
                                contentParts.push(cells[1]?.textContent || 'N/A');
                            }
                            
                            html += `<div class="detail-row highlighted">
                                <span>${contentParts.join(' ')}</span>
                            </div>`;
                        }
                        // If inside a continuous group but not at start, skip (handled above)
                    }
                    
                    html += '</div>';
                } else {
                    // Normal display - separate groups for each row
                    for (const { row, value } of rowData) {
                        const cells = row.querySelectorAll('td');
                        
                        // Highlight row
                        row.classList.add('highlight');
                        
                        // Highlight specific cells if columns specified
                        if (parsed.colNums) {
                            for (const colNum of parsed.colNums) {
                                const cellIndex = colNum - 1;
                                if (cells[cellIndex]) {
                                    cells[cellIndex].classList.add('highlight-cell');
                                }
                            }
                        }
                        
                        html += `<div class="detail-group">
                            <div class="detail-group-title">${cells[0].textContent}</div>`;
                        
                        if (parsed.colNums !== null) {
                            // Show only specified columns
                            for (const colNum of parsed.colNums) {
                                const cellIndex = colNum - 1;
                                const cellContent = cells[cellIndex]?.textContent || 'N/A';
                                const headerName = headers[cellIndex]?.textContent || `Column ${colNum}`;
                                
                                html += `<div class="detail-row highlighted">
                                    <span class="detail-label">${headerName}:</span>
                                    ${cellContent}
                                </div>`;
                            }
                        } else {
                            // Show all columns
                            for (let i = 0; i < cells.length; i++) {
                                html += `
                                    <div class="detail-row">
                                        <span class="detail-label">${headers[i].textContent}:</span>
                                        ${cells[i].textContent}
                                    </div>
                                `;
                            }
                        }
                        html += '</div>';
                    }
                }
                
                // Set title based on reference type
                let title = '';
                if (parsed.hasContinuous) {
                    title = `${columnHeaderName}: ${rowData.map(r => r.value).join(', ')}`;
                } else if (rowData.length === 1 && (!parsed.colNums || parsed.colNums.length === 1)) {
                    title = `Details: ${rowData[0].value}`;
                } else if (rowData.length === 1) {
                    title = `${rowData[0].value} - Selected Columns`;
                } else if (!parsed.colNums || parsed.colNums.length === 1) {
                    title = `Comparison: ${rowData.map(r => r.value).join(' & ')}`;
                } else {
                    title = `Multi-Row Multi-Column: ${rowData.map(r => r.value).join(' & ')}`;
                }
                
                document.getElementById('detailTitle').textContent = title;
                document.getElementById('detailContent').innerHTML = html;
                
                document.getElementById('overlay').classList.add('active');
                document.getElementById('detailPanel').classList.add('active');
            }
        }
        
        function closeDetail() {
            document.getElementById('overlay').classList.remove('active');
            document.getElementById('detailPanel').classList.remove('active');
            document.querySelectorAll('tbody tr').forEach(tr => tr.classList.remove('highlight'));
            document.querySelectorAll('tbody td').forEach(td => td.classList.remove('highlight-cell'));
        }
        
        // Initialize
        initPyodide().then(() => {
            console.log('System ready');
            // Auto-link all elements with auto-link-refs class after Pyodide loads
            document.querySelectorAll('.auto-link-refs').forEach(el => {
                autoLinkReferences(el);
            });
        });
        
        // Auto-detect and convert I(...) and R(...) patterns to links
        function autoLinkReferences(container) {
            // Process text nodes only to avoid breaking existing HTML
            const walker = document.createTreeWalker(
                container,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );
            
            const textNodes = [];
            while (walker.nextNode()) {
                textNodes.push(walker.currentNode);
            }
            
            // Regex to match I(...) or R(...) patterns
            const refPattern = /([IR]\([^)]+\))/g;
            
            textNodes.forEach(textNode => {
                const text = textNode.textContent;
                if (refPattern.test(text)) {
                    // Reset regex lastIndex
                    refPattern.lastIndex = 0;
                    
                    const fragment = document.createDocumentFragment();
                    let lastIndex = 0;
                    let match;
                    
                    while ((match = refPattern.exec(text)) !== null) {
                        // Add text before match
                        if (match.index > lastIndex) {
                            fragment.appendChild(document.createTextNode(text.slice(lastIndex, match.index)));
                        }
                        
                        // Create link for the reference
                        const link = document.createElement('a');
                        link.className = 'link';
                        link.setAttribute('data-ref', match[1]);
                        link.textContent = match[1];
                        link.href = '#';
                        fragment.appendChild(link);
                        
                        lastIndex = match.index + match[0].length;
                    }
                    
                    // Add remaining text
                    if (lastIndex < text.length) {
                        fragment.appendChild(document.createTextNode(text.slice(lastIndex)));
                    }
                    
                    // Replace the text node with the fragment
                    textNode.parentNode.replaceChild(fragment, textNode);
                }
            });
            
            // Re-attach event listeners to new links
            setupEventListeners();
        }
        
        // Load and render markdown content from external file
        async function loadMarkdownFile(url, targetElementId) {
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`Failed to load ${url}`);
                const markdown = await response.text();
                renderMarkdown(markdown, targetElementId);
            } catch (error) {
                console.error('Error loading markdown file:', error);
            }
        }
        
        // Load and execute external JS file containing text
        async function loadTextFile(url, targetElementId) {
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`Failed to load ${url}`);
                const text = await response.text();
                
                const targetElement = document.getElementById(targetElementId);
                if (targetElement) {
                    targetElement.innerHTML = text;
                    autoLinkReferences(targetElement);
                }
            } catch (error) {
                console.error('Error loading text file:', error);
            }
        }
        
        // Enhanced markdown to HTML converter with full support
        function renderMarkdown(markdown, targetElementId) {
            const targetElement = document.getElementById(targetElementId);
            if (!targetElement) return;
            
            let html = markdown
                // Code blocks (``` ```)
                .replace(/```(\w*)\n([\s\S]*?)```/g, '<pre><code class="language-$1">$2</code></pre>')
                // Inline code
                .replace(/`([^`]+)`/g, '<code>$1</code>')
                // Headers (must be before other processing)
                .replace(/^#### (.*$)/gim, '<h4>$1</h4>')
                .replace(/^### (.*$)/gim, '<h3>$1</h3>')
                .replace(/^## (.*$)/gim, '<h2>$1</h2>')
                .replace(/^# (.*$)/gim, '<h1>$1</h1>')
                // Horizontal rule
                .replace(/^---$/gim, '<hr>')
                // Bold and Italic combined
                .replace(/\*\*\*(.*?)\*\*\*/g, '<strong><em>$1</em></strong>')
                // Bold
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/__(.*?)__/g, '<strong>$1</strong>')
                // Italic
                .replace(/\*(.*?)\*/g, '<em>$1</em>')
                .replace(/_(.*?)_/g, '<em>$1</em>')
                // Strikethrough
                .replace(/~~(.*?)~~/g, '<del>$1</del>')
                // Blockquotes
                .replace(/^> (.*$)/gim, '<blockquote>$1</blockquote>')
                // Unordered lists
                .replace(/^\s*[-*+] (.*$)/gim, '<li>$1</li>')
                // Ordered lists
                .replace(/^\s*\d+\. (.*$)/gim, '<li>$1</li>')
                // Links [text](url)
                .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank">$1</a>')
                // Images ![alt](url)
                .replace(/!\[([^\]]*)\]\(([^)]+)\)/g, '<img src="$2" alt="$1" style="max-width:100%">')
                // Line breaks / paragraphs
                .replace(/\n\n+/g, '</p><p>')
                .replace(/\n/g, '<br>');
            
            // Wrap consecutive <li> in <ul>
            html = html.replace(/(<li>.*<\/li>)/gs, '<ul>$1</ul>');
            // Clean up multiple <ul> tags
            html = html.replace(/<\/ul>\s*<ul>/g, '');
            
            // Wrap consecutive blockquotes
            html = html.replace(/(<blockquote>.*<\/blockquote>)/gs, function(match) {
                return match.replace(/<\/blockquote>\s*<blockquote>/g, '<br>');
            });
            
            // Wrap in paragraph tags
            html = '<p>' + html + '</p>';
            
            // Clean up empty paragraphs
            html = html.replace(/<p>\s*<\/p>/g, '');
            html = html.replace(/<p>\s*(<h[1-6]>)/g, '$1');
            html = html.replace(/(<\/h[1-6]>)\s*<\/p>/g, '$1');
            html = html.replace(/<p>\s*(<ul>)/g, '$1');
            html = html.replace(/(<\/ul>)\s*<\/p>/g, '$1');
            html = html.replace(/<p>\s*(<pre>)/g, '$1');
            html = html.replace(/(<\/pre>)\s*<\/p>/g, '$1');
            html = html.replace(/<p>\s*(<hr>)\s*<\/p>/g, '$1');
            html = html.replace(/<p>\s*(<blockquote>)/g, '$1');
            html = html.replace(/(<\/blockquote>)\s*<\/p>/g, '$1');
            
            targetElement.innerHTML = html;
            autoLinkReferences(targetElement);
        }
        
        // Process inline text and return HTML with auto-linked references
        function processInlineText(text) {
            const refPattern = /([IR]\([^)]+\))/g;
            return text.replace(refPattern, '<a class="link" data-ref="$1" href="#">$1</a>');
        }
        
        // Process content on page load - auto-link any existing content
        document.addEventListener('DOMContentLoaded', () => {
            // Auto-link references in any element with class 'auto-link-refs'
            document.querySelectorAll('.auto-link-refs').forEach(el => {
                autoLinkReferences(el);
            });
            
            // Demo: Load sample markdown content
            const sampleMarkdown = `
# Sample Markdown Document

This document demonstrates **markdown support** with *automatic reference linking*.

## Validation Results

The validation process reviewed entry I(1,1.0) successfully. Item I(1,2.a) showed improvement. Test I(1,3.0.a.P) needs review.

### Status Summary

- Check status: R(1,2,3)
- Compare results: I(2,001+002,3)
- Full range: R(1,1-3,3)

## Experiment Data

> The experiments I(2,001-003,3) showed promising results across all test groups.

For detailed comparison, see I(2,001+002,3+4) which includes both Result and Remark columns.

---

**Note:** All references like R(2,1+2+3) are automatically converted to clickable links!
`;
            renderMarkdown(sampleMarkdown, 'markdownContent');
        });
        
        // Expose functions globally for external use
        window.TableRefSystem = {
            autoLinkReferences,
            loadMarkdownFile,
            loadTextFile,
            renderMarkdown,
            processInlineText
        };
    </script>
</body>
</html>
